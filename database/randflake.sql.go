// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: randflake.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const gCRandflakeLeases = `-- name: GCRandflakeLeases :exec
DELETE FROM randflake_nodes WHERE lease_end < $1
`

func (q *Queries) GCRandflakeLeases(ctx context.Context, leaseEnd int64) error {
	_, err := q.db.Exec(ctx, gCRandflakeLeases, leaseEnd)
	return err
}

const getRandflakeRangeLease = `-- name: GetRandflakeRangeLease :many
SELECT range_start, range_end FROM randflake_nodes
    WHERE
        range_start >= $1
        AND lease_end >= $2
    ORDER BY range_start ASC LIMIT $3
`

type GetRandflakeRangeLeaseParams struct {
	RangeStart int64 `json:"range_start"`
	LeaseEnd   int64 `json:"lease_end"`
	Limit      int32 `json:"limit"`
}

type GetRandflakeRangeLeaseRow struct {
	RangeStart int64 `json:"range_start"`
	RangeEnd   int64 `json:"range_end"`
}

func (q *Queries) GetRandflakeRangeLease(ctx context.Context, arg GetRandflakeRangeLeaseParams) ([]GetRandflakeRangeLeaseRow, error) {
	rows, err := q.db.Query(ctx, getRandflakeRangeLease, arg.RangeStart, arg.LeaseEnd, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRandflakeRangeLeaseRow
	for rows.Next() {
		var i GetRandflakeRangeLeaseRow
		if err := rows.Scan(&i.RangeStart, &i.RangeEnd); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const renewRandflakeRangeLease = `-- name: RenewRandflakeRangeLease :one
UPDATE randflake_nodes SET lease_end = $1 WHERE id = $2 AND lease_holder = $3 AND lease_end >= $4 RETURNING id, range_start, range_end, lease_holder, lease_start, lease_end
`

type RenewRandflakeRangeLeaseParams struct {
	LeaseEnd    int64       `json:"lease_end"`
	ID          int64       `json:"id"`
	LeaseHolder pgtype.UUID `json:"lease_holder"`
	LeaseEnd_2  int64       `json:"lease_end_2"`
}

func (q *Queries) RenewRandflakeRangeLease(ctx context.Context, arg RenewRandflakeRangeLeaseParams) (RandflakeNode, error) {
	row := q.db.QueryRow(ctx, renewRandflakeRangeLease,
		arg.LeaseEnd,
		arg.ID,
		arg.LeaseHolder,
		arg.LeaseEnd_2,
	)
	var i RandflakeNode
	err := row.Scan(
		&i.ID,
		&i.RangeStart,
		&i.RangeEnd,
		&i.LeaseHolder,
		&i.LeaseStart,
		&i.LeaseEnd,
	)
	return i, err
}

const tryCreateRandflakeRangeLease = `-- name: TryCreateRandflakeRangeLease :one
INSERT INTO randflake_nodes (range_start, range_end, lease_holder, lease_start, lease_end)
    SELECT $1, $2, $3, $4, $5
        WHERE NOT EXISTS (
            SELECT id, range_start, range_end, lease_holder, lease_start, lease_end FROM randflake_nodes
                WHERE
                    (range_start <= $4 AND range_end >= $3) -- overlap
                    AND randflake_nodes.lease_end >= $6 -- not expired
        )
RETURNING id, range_start, range_end, lease_holder, lease_start, lease_end
`

type TryCreateRandflakeRangeLeaseParams struct {
	RangeStart  int64       `json:"range_start"`
	RangeEnd    int64       `json:"range_end"`
	LeaseHolder pgtype.UUID `json:"lease_holder"`
	LeaseStart  int64       `json:"lease_start"`
	LeaseEnd    int64       `json:"lease_end"`
	LeaseEnd_2  int64       `json:"lease_end_2"`
}

func (q *Queries) TryCreateRandflakeRangeLease(ctx context.Context, arg TryCreateRandflakeRangeLeaseParams) (RandflakeNode, error) {
	row := q.db.QueryRow(ctx, tryCreateRandflakeRangeLease,
		arg.RangeStart,
		arg.RangeEnd,
		arg.LeaseHolder,
		arg.LeaseStart,
		arg.LeaseEnd,
		arg.LeaseEnd_2,
	)
	var i RandflakeNode
	err := row.Scan(
		&i.ID,
		&i.RangeStart,
		&i.RangeEnd,
		&i.LeaseHolder,
		&i.LeaseStart,
		&i.LeaseEnd,
	)
	return i, err
}
